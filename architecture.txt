Assumptions:
 * disk seek time is immediate, node CPU processing time is immediate
 * data blocks have no content, we simulate time it takes to transfer the data

Architecture
~~~~~~~~~~~~

1. World creator

Set of nodes, links and content is called "world". The world must be reproduceable, so that others might analyse problematic issues that happen in one world but not the others. Thus the world is created from 512 bit (64bytes) seed.

The seed is used to create "random" set of bits that are used to decide various parameters of the world. For easier implementation and to save memory, all numbers in the world are represented as power of 2. Thus word "random" in this document is not truly random, but based on seeded set of bits.

Initial parameters of world are: Number of nodes, number of connections of each nodes, size of content

World generation procedure:
* Create requested number of objects of class node
* Create random links between nodes, with random bandwidth and latency, specified in milliseconds
* Populate nodes with random content, varying in number of blocks and sizes
* Populate nodes with wanted blocks (future: request urgency)

2. Routing class

Each node inherits same routing class developer wants to test. The class should access following data objects:
* list of neigbour nodes
* list of wanted blocks
* arrived data blocks

3. The Simulation

Simulation granularity is 1 millisecond. Sent data are registered in global "transit" callback queue so that target node is woken up at given time in the future. "Transfer time" might be affected by link capacity (tracked by per node link_fill_up parameter) of both sides.

The simulation finishes when all demands are satisfied or "transit" queue is empty.

Open questions:
 * what is best architecture for this? Start goroutine for each node? Use channels? Or several threads working on a huge array?
 * The architecture should allow more than one node, how do we do that?
 
I am considering to partition the network on CPU basis. E.g. create world, run thread per CPU, allocate nodes to threads evenly. Establish channels between threads for "transit" and "time" notifications. The approach would scale out across several machines nicely. Ideas?
